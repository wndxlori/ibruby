Index: activerecord/lib/active_record.rb
===================================================================
--- activerecord/lib/active_record.rb	(revision 5680)
+++ activerecord/lib/active_record.rb	(working copy)
@@ -74,7 +74,7 @@
 end
 
 unless defined?(RAILS_CONNECTION_ADAPTERS)
-  RAILS_CONNECTION_ADAPTERS = %w( mysql postgresql sqlite firebird sqlserver db2 oracle sybase openbase frontbase )
+  RAILS_CONNECTION_ADAPTERS = %w( mysql postgresql sqlite firebird sqlserver db2 oracle sybase openbase frontbase interbase )
 end
 
 RAILS_CONNECTION_ADAPTERS.each do |adapter|
Index: activerecord/lib/active_record/base.rb
===================================================================
--- activerecord/lib/active_record/base.rb	(revision 5680)
+++ activerecord/lib/active_record/base.rb	(working copy)
@@ -346,7 +346,7 @@
     # adapters for, e.g., your development and test environments.
     cattr_accessor :schema_format 
     @@schema_format = :ruby
-
+    
     class << self # Class methods
       # Find operates with three different retrieval approaches:
       #
Index: activerecord/lib/active_record/connection_adapters/abstract_adapter.rb
===================================================================
--- activerecord/lib/active_record/connection_adapters/abstract_adapter.rb	(revision 5680)
+++ activerecord/lib/active_record/connection_adapters/abstract_adapter.rb	(working copy)
@@ -24,10 +24,18 @@
       include Quoting, DatabaseStatements, SchemaStatements
       @@row_even = true
       
+      # Some databases use UPPER to determine case insignificance rather than LOWER
+      # This is particularly used in Validations
+      CASE_INSIGNIFICANT_LOWER = :CASE_INSIGNIFICANT_LOWER
+      CASE_INSIGNIFICANT_UPPER = :CASE_INSIGNIFICANT_UPPER
+      
+      attr_accessor :case_insignificant_test
+      
       def initialize(connection, logger = nil) #:nodoc:
         @connection, @logger = connection, logger
         @runtime = 0
         @last_verification = 0
+        @case_insignificant_test = CASE_INSIGNIFICANT_LOWER
       end
 
       # Returns the human-readable name of the adapter.  Use mixed case - one
Index: activerecord/test/abstract_unit.rb
===================================================================
--- activerecord/test/abstract_unit.rb	(revision 5680)
+++ activerecord/test/abstract_unit.rb	(working copy)
@@ -35,13 +35,17 @@
     end
   end
 
-  def assert_queries(num = 1)
+  def assert_queries(num = 1)
+    puts "1"
     ActiveRecord::Base.connection.class.class_eval do
-      self.query_count = 0
+      self.query_count = 0
+      puts "aliased"
       alias_method :execute, :execute_with_query_counting
     end
-    yield
-  ensure
+    yield
+    puts "back from yield"
+  ensure
+    puts "ensuring"
     ActiveRecord::Base.connection.class.class_eval do
       alias_method :execute, :execute_without_query_counting
     end
@@ -67,8 +71,10 @@
   @@ignore_list = [/^SELECT currval/, /^SELECT CAST/, /^SELECT @@IDENTITY/]
 
   alias_method :execute_without_query_counting, :execute
-  def execute_with_query_counting(sql, name = nil, &block)
-    self.query_count += 1 unless @@ignore_list.any? { |r| sql =~ r }
+  def execute_with_query_counting(sql, name = nil, &block)
+    puts "here"
+    self.query_count += 1 unless @@ignore_list.any? { |r| sql =~ r }
+    puts "query count :#{self.query_count}"
     execute_without_query_counting(sql, name, &block)
   end
 end
Index: activerecord/test/aggregations_test.rb
===================================================================
--- activerecord/test/aggregations_test.rb	(revision 5680)
+++ activerecord/test/aggregations_test.rb	(working copy)
@@ -3,8 +3,10 @@
 
 class AggregationsTest < Test::Unit::TestCase
   fixtures :customers
+  
 
   def test_find_single_value_object
+    puts "looking for david!"
     assert_equal 50, customers(:david).balance.amount
     assert_kind_of Money, customers(:david).balance
     assert_equal 300, customers(:david).balance.exchange_to("DKK").amount
@@ -46,6 +48,7 @@
   end
 
   def test_reloaded_instance_refreshes_aggregations
+    puts "reloaded #{customers(:david)}"
     assert_equal "35.544623640962634", customers(:david).gps_location.latitude
     assert_equal "-105.9309951055148", customers(:david).gps_location.longitude
 
Index: activerecord/test/associations_test.rb
===================================================================
--- activerecord/test/associations_test.rb	(revision 5680)
+++ activerecord/test/associations_test.rb	(working copy)
@@ -392,7 +392,8 @@
     assert_equal a, firm.account(true)
   end
 
-  def test_not_resaved_when_unchanged
+  def test_not_resaved_when_unchanged
+    puts "bad sql"
     firm = Firm.find(:first, :include => :account)
     assert_queries(1) { firm.save! }
 
@@ -1795,13 +1796,14 @@
   def test_join_table_alias
     assert_equal 3, Developer.find(:all, :include => {:projects => :developers}, :conditions => 'developers_projects_join.joined_on IS NOT NULL').size
   end
-  
+  
   def test_join_with_group
     group = Developer.columns.inject([]) do |g, c|
-      g << "developers.#{c.name}"
+      g << "developers.#{Developer.connection.quote_column_name(c.name)}"
       g << "developers_projects_2.#{c.name}"
     end
-    Project.columns.each { |c| group << "projects.#{c.name}" }
+    Project.columns.each { |c| group << "projects.#{Project.connection.quote_column_name(c.name)}" }
+    Project.columns.each { |c| puts "Column name for projects is #{Project.connection.quote_column_name(c.name)}" }
 
     assert_equal 3, Developer.find(:all, :include => {:projects => :developers}, :conditions => 'developers_projects_join.joined_on IS NOT NULL', :group => group.join(",")).size
   end
Index: activerecord/test/base_test.rb
===================================================================
--- activerecord/test/base_test.rb	(revision 5680)
+++ activerecord/test/base_test.rb	(working copy)
@@ -579,6 +579,7 @@
   end
   
   def test_default_values
+    puts "before topic"
     topic = Topic.new
     assert topic.approved?
     assert_nil topic.written_on
@@ -1440,6 +1441,8 @@
     assert xml.include?(%(<author-name>David</author-name>))
     assert xml.include?(%(<id type="integer">1</id>))
     assert xml.include?(%(<replies-count type="integer">1</replies-count>))
+    puts "written on: #{written_on_in_current_timezone}"
+    puts "#{xml.to_s}"
     assert xml.include?(%(<written-on type="datetime">#{written_on_in_current_timezone}</written-on>))
     assert xml.include?(%(<content>Have a nice day</content>))
     assert xml.include?(%(<author-email-address>david@loudthinking.com</author-email-address>))
Index: activerecord/test/connections/native_sqlite3/in_memory_connection.rb
===================================================================
--- activerecord/test/connections/native_sqlite3/in_memory_connection.rb	(revision 5680)
+++ activerecord/test/connections/native_sqlite3/in_memory_connection.rb	(working copy)
@@ -15,4 +15,4 @@
 
 make_connection(ActiveRecord::Base, 'sqlite.sql')
 make_connection(Course, 'sqlite2.sql')
-  load("#{File.dirname(__FILE__)}/../../fixtures/db_definitions/schema.rb"))
+  load("#{File.dirname(__FILE__)}/../../fixtures/db_definitions/schema.rb")
Index: activerecord/test/method_scoping_test.rb
===================================================================
--- activerecord/test/method_scoping_test.rb	(revision 5680)
+++ activerecord/test/method_scoping_test.rb	(working copy)
@@ -6,7 +6,7 @@
 require 'fixtures/category'
 
 class MethodScopingTest < Test::Unit::TestCase
-  fixtures :developers, :projects, :comments, :posts
+  fixtures :developers, :projects, :comments, :posts, :developers_projects
   
   def test_set_conditions
     Developer.with_scope(:find => { :conditions => 'just a test...' }) do
@@ -189,6 +189,7 @@
 
   def test_nested_scoped_find_merged_include
     # :include's remain unique and don't "double up" when merging
+    
     Developer.with_scope(:find => { :include => :projects, :conditions => "projects.id = 2" }) do
       Developer.with_scope(:find => { :include => :projects }) do
         assert_equal 1, Developer.instance_eval('current_scoped_methods')[:find][:include].length
Index: activerecord/test/migration_test.rb
===================================================================
--- activerecord/test/migration_test.rb	(revision 5680)
+++ activerecord/test/migration_test.rb	(working copy)
@@ -204,17 +204,27 @@
     def test_native_decimal_insert_manual_vs_automatic
       # SQLite3 always uses float in violation of SQL
       # 16 decimal places
-      correct_value = (current_adapter?(:SQLiteAdapter) ? '0.123456789012346E20' : '0012345678901234567890.0123456789').to_d
+      precision = '30'
+      if current_adapter?(:SQLiteAdapter)
+         correct_value = '0.123456789012346E20' 
+      elsif current_adapter?(:InterBaseAdapter)
+         correct_value = '12345678.0123456789'
+         precision = '18'
+      else
+         correct_value = '0012345678901234567890.0123456789'
+      end
 
       Person.delete_all
-      Person.connection.add_column "people", "wealth", :decimal, :precision => '30', :scale => '10'
+      Person.connection.add_column "people", "wealth", :decimal, :precision => precision, :scale => '10'
       Person.reset_column_information
 
       # Do a manual insertion
-      if current_adapter?(:OracleAdapter)
-        Person.connection.execute "insert into people (id, wealth) values (people_seq.nextval, 12345678901234567890.0123456789)"
+      if current_adapter?(:OracleAdapter) 
+        Person.connection.execute "insert into people (id, wealth) values (people_seq.nextval, #{correct_value.to_s})"
+      elsif current_adapter?(:InterBaseAdapter)
+        Person.connection.execute( "insert into people (id, wealth) values (1, #{correct_value.to_s})" )
       else
-        Person.connection.execute "insert into people (wealth) values (12345678901234567890.0123456789)"
+        Person.connection.execute "insert into people (wealth) values (#{correct_value.to_s})"
       end
 
       # SELECT
@@ -222,20 +232,20 @@
       assert_kind_of BigDecimal, row.wealth
 
       # If this assert fails, that means the SELECT is broken!
-      assert_equal correct_value, row.wealth
+      assert_equal correct_value.to_d, row.wealth
 
       # Reset to old state
       Person.delete_all
 
       # Now use the Rails insertion
-      assert_nothing_raised { Person.create :wealth => BigDecimal.new("12345678901234567890.0123456789") }
+      assert_nothing_raised { Person.create :wealth => BigDecimal.new("#{correct_value.to_s}") }
 
       # SELECT
       row = Person.find(:first)
       assert_kind_of BigDecimal, row.wealth
 
       # If these asserts fail, that means the INSERT (create function, or cast to SQL) is broken!
-      assert_equal correct_value, row.wealth
+      assert_equal correct_value.to_d, row.wealth
 
       # Reset to old state
       Person.connection.del_column "people", "wealth" rescue nil
@@ -248,11 +258,19 @@
       Person.connection.add_column "people", "bio", :text
       Person.connection.add_column "people", "age", :integer
       Person.connection.add_column "people", "height", :float
-      Person.connection.add_column "people", "wealth", :decimal, :precision => '30', :scale => '10'
+      if current_adapter?(:InterBaseAdapter)
+        Person.connection.add_column "people", "wealth", :decimal, :precision => '18', :scale => '10'
+      else
+        Person.connection.add_column "people", "wealth", :decimal, :precision => '30', :scale => '10'
+      end
       Person.connection.add_column "people", "birthday", :datetime
       Person.connection.add_column "people", "favorite_day", :date
       Person.connection.add_column "people", "male", :boolean
-      assert_nothing_raised { Person.create :first_name => 'bob', :last_name => 'bobsen', :bio => "I was born ....", :age => 18, :height => 1.78, :wealth => BigDecimal.new("12345678901234567890.0123456789"), :birthday => 18.years.ago, :favorite_day => 10.days.ago, :male => true }
+      bd_wealth = current_adapter?(:InterBaseAdapter) ? "12345678.0123456789" : "12345678901234567890.0123456789"
+      assert_nothing_raised { Person.create :first_name => 'bob', :last_name => 'bobsen', 
+          :bio => "I was born ....", :age => 18, :height => 1.78, 
+          :wealth => BigDecimal.new(bd_wealth), 
+          :birthday => 18.years.ago, :favorite_day => 10.days.ago, :male => true }
       bob = Person.find(:first)
 
       assert_equal 'bob', bob.first_name
@@ -265,6 +283,8 @@
       if current_adapter?(:SQLiteAdapter)
         # SQLite3 uses float in violation of SQL. Test for 16 decimal places.
         assert_equal BigDecimal.new('0.123456789012346E20'), bob.wealth
+      elsif current_adapter?(:InterBaseAdapter)
+        assert_equal BigDecimal.new(bd_wealth), bob.wealth
       else
         assert_equal BigDecimal.new("0012345678901234567890.0123456789"), bob.wealth
       end
@@ -380,7 +400,7 @@
     def test_rename_table_with_an_index
       begin
         ActiveRecord::Base.connection.create_table :octopuses do |t|
-          t.column :url, :string
+          t.column :url, :string, :limit => 250   #required for InterBase/Firebird 1.0/1.5 to work (252 byte index max size)
         end
         ActiveRecord::Base.connection.add_index :octopuses, :url
         
@@ -419,11 +439,11 @@
     end
 
     def test_change_column_with_new_default
-      Person.connection.add_column "people", "administrator", :boolean, :default => 1
+      Person.connection.add_column "people", "administrator", :boolean, :default => true
       Person.reset_column_information
       assert Person.new.administrator?
 
-      assert_nothing_raised { Person.connection.change_column "people", "administrator", :boolean, :default => 0 }
+      assert_nothing_raised { Person.connection.change_column "people", "administrator", :boolean, :default => false }
       Person.reset_column_information
       assert !Person.new.administrator?
     end
@@ -645,6 +665,7 @@
       assert Reminder.create("content" => "hello world", "remind_at" => Time.now)
       assert_equal "hello world", Reminder.find(:first).content
 
+      puts "about to go down!"
       WeNeedReminders.down
       assert_raises(ActiveRecord::StatementInvalid) { Reminder.find(:first) }
     ensure
@@ -655,7 +676,7 @@
     end
 
 #   FrontBase does not support default values on BLOB/CLOB columns
-    unless current_adapter?(:FrontBaseAdapter)
+    unless current_adapter?(:FrontBaseAdapter) || current_adapter?(:InterBaseAdapter)
       def test_create_table_with_binary_column
         Person.connection.drop_table :binary_testings rescue nil
 
Index: activerecord/test/readonly_test.rb
===================================================================
--- activerecord/test/readonly_test.rb	(revision 5680)
+++ activerecord/test/readonly_test.rb	(working copy)
@@ -58,8 +58,10 @@
   end
 
   def test_has_many_find_readonly
+    puts "here"
     post = Post.find(1)
     assert !post.comments.empty?
+    gets
     assert !post.comments.any?(&:readonly?)
     assert !post.comments.find(:all).any?(&:readonly?)
     assert post.comments.find(:all, :readonly => true).all?(&:readonly?)
